package structure.tree;
// 概念
// 节点: 数元素以及指向子树的分支构成
// 根节点: 非空树中无前驱节点的节点
// 父节点
//
// 节点的权(节点值)
// 路径(从root找到该节点的路线)
// 层:
// 子树.以某子节点作为根的子树
// 树的深度: 树中节点的最大层次
// 树的高度(最大层数)
// 森林:多子树构成森林
// 节点的高度: 节点到叶子节点的最短路径
// 节点的深度: 根节点到指定节点的最短路径
// 节点的度: 节点拥有的子树数
// 树的度: 树内各节点的度的最大值
//   叶子节点(没有子节点的节点) 度=0
// 森林: 是m(m>=0)棵树互不相交的树的集合.把根节点删除,树就变成了失灵,一个树可以看成一个特殊的森林.
//   给森林中的各子树加上一个双亲节点,森林就变成了树(树一定是森林,森林不一定是树)

// 有序树: 数中的各子树从左到右有次序(最左边的为第一个孩子)
// 无序树: 树中节点的各子树无次序


// 二叉树:
//  二叉树是n(n>=0)个节点的有限集,它或者是空集(n=0),
//  或者由一个根节点及两颗互不相交的分别称作这个根的左子树和右子树的二叉树组成
// 特点:
//  1.每个节点最多有两个孩子(二叉树中不存在度大于2的节点)
//  2.子树有左右之分,其次次序不能颠倒
//  3.二叉树可以是空集合,根可以有空的左子树或空的右子树
// 注意:
//  二叉树不是数的特殊情况,它们是两个概念
//  二叉树节点的子树要区分左子树和右子树,即使只有一颗也要进行区分说明他是左子树还是右子树
//  树当节点只有一个孩子时,就无须区分它是左还是右的次序.因此二者是不同的.这是二叉树与树的主要差别
//  1.性质1:在二叉树的第i层上最多有2^(n-1)个节点(i>=1) [可用归纳法证明]
//  2.性质2:深度为k的二叉树最多有(2^n)-1个节点(k>=1) [可由性质1推导]
//  3.性质3:对然后一颗二叉树T1,如果其叶子数为n0,度为2(有两个子树)的节点数为n2 则,n0 = n2+1
//      总边数=总节点数-1=n2*2+n1*1(度为2会产生2条边)
//      等式 n-1=n2*2+n1*1 => n=n2*2+n1*1+1 又 n = n2+n1+n0
//      约掉n0 = n2+1
//      (性质3用处不大,但边的个数和节点的关系的关键很重要)


// 问题: 为什么要也就两种特殊的形式: 因为他们在顺序存储方式下可以复原!

// 满二叉树:
//  如果该二叉树的所有叶子节点都在最后一层,并且节点总数=2^n-1(n为层数)
// 特点:
//  1.每一层上的结点数都是最大节点数(即每层都满)
//  2.叶子节点全部在最底层
// 对满二叉树节点位置进行编号:
//  编号规则:从根节点卡开始,自上而下,从左到右
//  每个节点位置都有元素

// 完全二叉树:
//  定义1:深度为k的具有n个节点的二叉树,当且仅当其每一个节点都与深度为k的
//  满二叉树中的编号为1~n的节点一一对应时.称之为完全二叉树
//  定义2: 在满二叉树胡总,从最后一个节点开始,连续去掉任意个节点,即是一颗
//  完全二叉树(一定是连续去掉)
// 特点:
//  1.叶子节点只可能发布在层次最大的两层上.
//  2.对任一记得,如果其右子树的最大层次为i.则其左子树的最大层数必为i或i+1
// 性质:
//  1.具有n个节点的完全二叉树的深度└log2 n┘+1
//    注:└x┘:称作x的底,表示不大于x的最大整数,
//    推导: 由完全二叉树定义得到(2^k)-1<n<=2k-1 => └log2 n┘+1
//    表明了完全二叉树节点数n和完全二叉树深度k的关系
//  2.如果对一颗有n个节点的完全二叉树(深度为└log2 n┘+1)的节点按层序编号(从第一层到第 └log2 n┘+1层,每层从左至右),
//    则对任一节点i(1<=i<=n),有
//    1)如果i=1,则节点i是二叉树的根,无双亲;如果i>1则其双亲节点└i/2┘
//    2)如果2i>n,则节点i是叶子节点,无左孩子;否则其左孩子是节点2i
//    3)如果2i+1>n,则节点i是无右孩子;否则其右孩子是节点2i+1;
//    表明了完全二叉树中双亲节点编号与孩子编号之间的关系
// 满二叉树一定是完全二叉树,但是完全二叉树不一定是满二叉树

// 二叉树的存储结构:
//  顺序存储结构
//  链式存储结构: 二叉链表,三叉链表
// 二叉树的顺序存储:
//  实现:按满二叉树的节点层次编号作为数组的下标,依次存放二叉树中的数据元素.[满二叉树大小的数组]
//  特点: 节点间关系蕴含在存储位置中
//  好处:比较简单
//  适用于满二叉树和完全二叉树
//  缺点:大小固定,不适合变化大的.空节点也占空间浪费空间

// 线索二叉树
//   当用二叉链表作为数的存储结构时,可以很方便地找到某个节点的左右孩子;
// 但一般情况下,无法直接找到节点在某种遍历序列中的前驱和后续节点.
// 提出的问题:
//   如何查找特定遍历序列中的二叉树节点的前驱和后续??
// 解决的方法:
//  1.通过遍历寻找-(费时间)
//  2.再增设前驱,后继指针域-(增加了存储负担)
//  3.利用二叉链表中的空指针域.
// 二叉树链表中空指针域的数量:
//   具有n个节点的二叉链表中,一共有2n个指针域;
// 因为n个节点中有n-1个孩子,即2n个指针域中,有
// n-1个用来指示节点的左右孩子,其余n+1个指针域
// 为空
// 利用二叉链表中的空指针域:
//    如果某个节点的左孩子为空,则将空左孩子指针域改为指向前驱,
//    如果某节点的右孩子为空,则将空的右孩子指针域改为指向其后续
// 为区分左left和right指针到底是指向孩子的指针,还是指向前驱或者后续的指针,对二叉链表中的每个节点增设两个标志域ltag和rtag,并约定
//   ltag=0 left指向该节点的左孩子
//   ltag=1 left指向该节点的前驱
//   rtag=0 left指向该节点的右孩子
//   rtag=0 left指向该节点的后续
//   增加一个头结点,左指向根节点,右指向遍历序列的最后一个节点


// 二叉树的遍历
// 前序遍历:先输出父节点,再遍历左子树和右子树
// 中序遍历:先遍历左子树,再输出父节点,再遍历右子树
// 后序遍历:先遍历左子树,再遍历右子树,后输出父节点
// 小结:看输出父节点的顺序,就确定是前序,中序还是后序

// 也可嵌套集合和凹入还有广义图表示Tree
public class Tree {
}
