package structure.tree;
// 概念
// 节点: 数元素以及指向子树的分支构成
// 根节点: 非空树中无前驱节点的节点
// 父节点
//
// 节点的权(节点值)
// 路径(从root找到该节点的路线)
// 层:
// 子树.以某子节点作为根的子树
// 树的深度: 树中节点的最大层次
// 树的高度(最大层数)
// 森林:多子树构成森林
// 节点的高度: 节点到叶子节点的最短路径
// 节点的深度: 根节点到指定节点的最短路径
// 节点的度: 节点拥有的子树数
// 树的度: 树内各节点的度的最大值
//   叶子节点(没有子节点的节点) 度=0
// 森林: 是m(m>=0)棵树互不相交的树的集合.把根节点删除,树就变成了失灵,一个树可以看成一个特殊的森林.
//   给森林中的各子树加上一个双亲节点,森林就变成了树(树一定是森林,森林不一定是树)

// 有序树: 数中的各子树从左到右有次序(最左边的为第一个孩子)
// 无序树: 树中节点的各子树无次序


// 二叉树:
//  二叉树是n(n>=0)个节点的有限集,它或者是空集(n=0),
//  或者由一个根节点及两颗互不相交的分别称作这个根的左子树和右子树的二叉树组成
// 特点:
//  1.每个节点最多有两个孩子(二叉树中不存在度大于2的节点)
//  2.子树有左右之分,其次次序不能颠倒
//  3.二叉树可以是空集合,根可以有空的左子树或空的右子树
// 注意:
//  二叉树不是数的特殊情况,它们是两个概念
//  二叉树节点的子树要区分左子树和右子树,即使只有一颗也要进行区分说明他是左子树还是右子树
//  树当节点只有一个孩子时,就无须区分它是左还是右的次序.因此二者是不同的.这是二叉树与树的主要差别
//  1.性质1:在二叉树的第i层上最多有2^(n-1)个节点(i>=1) [可用归纳法证明]
//  2.性质2:深度为k的二叉树最多有(2^n)-1个节点(k>=1) [可由性质1推导]
//  3.性质3:对然后一颗二叉树T1,如果其叶子数为n0,度为2(有两个子树)的节点数为n2 则,n0 = n2+1
//      总边数=总节点数-1=n2*2+n1*1(度为2会产生2条边)
//      等式 n-1=n2*2+n1*1 => n=n2*2+n1*1+1 又 n = n2+n1+n0
//      约掉n0 = n2+1
//      (性质3用处不大,但边的个数和节点的关系的关键很重要)


// 问题: 为什么要也就两种特殊的形式: 因为他们在顺序存储方式下可以复原!

// 满二叉树:
//  如果该二叉树的所有叶子节点都在最后一层,并且节点总数=2^n-1(n为层数)
// 特点:
//  1.每一层上的结点数都是最大节点数(即每层都满)
//  2.叶子节点全部在最底层
// 对满二叉树节点位置进行编号:
//  编号规则:从根节点卡开始,自上而下,从左到右
//  每个节点位置都有元素

// 完全二叉树:
//  定义1:深度为k的具有n个节点的二叉树,当且仅当其每一个节点都与深度为k的
//  满二叉树中的编号为1~n的节点一一对应时.称之为完全二叉树
//  定义2: 在满二叉树胡总,从最后一个节点开始,连续去掉任意个节点,即是一颗
//  完全二叉树(一定是连续去掉)
// 特点:
//  1.叶子节点只可能发布在层次最大的两层上.
//  2.对任一记得,如果其右子树的最大层次为i.则其左子树的最大层数必为i或i+1
// 性质:
//  1.具有n个节点的完全二叉树的深度└log2 n┘+1
//    注:└x┘:称作x的底,表示不大于x的最大整数,
//    推导: 由完全二叉树定义得到(2^k)-1<n<=2k-1 => └log2 n┘+1
//    表明了完全二叉树节点数n和完全二叉树深度k的关系
//  2.如果对一颗有n个节点的完全二叉树(深度为└log2 n┘+1)的节点按层序编号(从第一层到第 └log2 n┘+1层,每层从左至右),
//    则对任一节点i(1<=i<=n),有
//    1)如果i=1,则节点i是二叉树的根,无双亲;如果i>1则其双亲节点└i/2┘
//    2)如果2i>n,则节点i是叶子节点,无左孩子;否则其左孩子是节点2i
//    3)如果2i+1>n,则节点i是无右孩子;否则其右孩子是节点2i+1;
//    表明了完全二叉树中双亲节点编号与孩子编号之间的关系
// 满二叉树一定是完全二叉树,但是完全二叉树不一定是满二叉树

// 二叉树的存储结构:
//  顺序存储结构
//  链式存储结构: 二叉链表,三叉链表
// 二叉树的顺序存储:
//  实现:按满二叉树的节点层次编号作为数组的下标,依次存放二叉树中的数据元素.[满二叉树大小的数组]
//  特点: 节点间关系蕴含在存储位置中
//  好处:比较简单
//  适用于满二叉树和完全二叉树
//  缺点:大小固定,不适合变化大的.空节点也占空间浪费空间

// 线索二叉树
//   当用二叉链表作为数的存储结构时,可以很方便地找到某个节点的左右孩子;
// 但一般情况下,无法直接找到节点在某种遍历序列中的前驱和后续节点.
// 提出的问题:
//   如何查找特定遍历序列中的二叉树节点的前驱和后续??
// 解决的方法:
//  1.通过遍历寻找-(费时间)
//  2.再增设前驱,后继指针域-(增加了存储负担)
//  3.利用二叉链表中的空指针域.
// 二叉树链表中空指针域的数量:
//   具有n个节点的二叉链表中,一共有2n个指针域;
// 因为n个节点中有n-1个孩子,即2n个指针域中,有
// n-1个用来指示节点的左右孩子,其余n+1个指针域
// 为空
// 利用二叉链表中的空指针域:
//    如果某个节点的左孩子为空,则将空左孩子指针域改为指向前驱,
//    如果某节点的右孩子为空,则将空的右孩子指针域改为指向其后续
// 为区分左left和right指针到底是指向孩子的指针,还是指向前驱或者后续的指针,对二叉链表中的每个节点增设两个标志域ltag和rtag,并约定
//   ltag=0 left指向该节点的左孩子
//   ltag=1 left指向该节点的前驱
//   rtag=0 left指向该节点的右孩子
//   rtag=0 left指向该节点的后续
//   增加一个头结点,左指向根节点,右指向遍历序列的最后一个节点


// 二叉树的遍历
// 前序遍历:先输出父节点,再遍历左子树和右子树
// 中序遍历:先遍历左子树,再输出父节点,再遍历右子树
// 后序遍历:先遍历左子树,再遍历右子树,后输出父节点
// 小结:看输出父节点的顺序,就确定是前序,中序还是后序

// 也可嵌套集合和凹入还有广义图表示Tree

// 同样的操作,改变了比较的顺序改变,操作的次数就减少很多,判断树效率高了不少
// 如何找到效率最高的判别树?
// 哈夫曼树(最优二叉树)
// 路径: 从树中的一个节点到另一个节点之间的分支构成这个两个节点间的路径
// 节点的路径长度: 量节点间路径上的分支数
// 数的路径长度: 从树根到每一个阶段的路径长度之和.记作TL. TL
// 权:将树中节点赋值给一个有着某种含义的数值,则这个数值称为该节点的权
// 节点的带权路径长度: 从根节点到该节点之间的路径长度与该节点的权的乘积
// 树的带权路径长度: 树中所有叶子节点的带权路径长度之和,记作WPL
// 结点数目相同的二叉树中,完全二叉树是路径长度最短的二叉树(反过来就不一定)

// 哈夫曼树: 最优树 带权路径长度最短的二叉树(度相同才有比较的意义)
// 特点: 哈夫曼树中权越大的叶子离根越近
// :
// 哈夫曼算法:(构建哈夫曼树的算法)
//  思路: 构造哈夫曼树时首先选择权值最小的叶子节点来构造

// 1)根据n个给定的权值{W1,W2,...Wn}构成n颗二叉树的森林F={T1,T2,.Tn},其中Ti只有一个带权为Wi的根节点.
//     [构造森林全是根]
// 2)在F中选取两颗根节点的权值最小的树作为左右子树,构造一颗新的二叉树,
//   且设置新的二叉树的根节点的权值为其左右子树上根节点的权值之和
//     [选用两小造新树]
// 3)在F中删除这两颗树,同时将新得到的二叉树加入森林中.
//     [删除两小添新人]
// 4)重复(2)和(3),直到森林中只有一棵树为止,这棵树即为哈夫曼树
//     [重复2、3剩单根]
// 哈夫曼树的节点的度数为0或2,没有度为1的节点.包含n个叶子节点的哈夫曼树中共有2n-1个节点
// 包含n棵树的森林要经过n-1次合并才能形成哈夫曼树,功能产生n-1个新节点

// 总结:
// 1.在哈夫曼算法中,初始有n颗二叉树,要经过n-1次合并最终形成哈夫曼树
// 2.经过n-1次合并产生n-1个新节点,且这个n-1个新节点都是两个孩子的分支节点

// 哈夫曼编码
// 关键:要设计长度不等的编码,则必须使任一字符的编码都不是另一个字符的编码的前缀.这种编码称作前缀编码
// 方法:
//    1.统计字符集中每个字符在电文中出现的平均概率
//    2.利用哈夫曼树的特点:权越大的叶子离根越近;将每个字符的概率值作为权值,构造哈夫曼树.则概率越大的节点,路径越短.
//    3.在哈夫曼树的每个分支上标上0或1:
//         节点的左分支标0,右分支标1
//         把从根到每个叶子的路径上的标号连接起来,作为该叶子代表的字符的编码
// 问题:
//  1.为什么哈夫曼编码能够保证是前缀编码
//     因为没有一片树叶是另一片树叶的祖先,所以每个叶节点的编码就不可能是其他叶结点编码的前缀
//  2.为什么哈夫曼编码能够保证字符串编码总长最短
//     因为哈夫曼树的带权路径长度最短,故字符编码的总长最短
//    性质1: 哈夫曼编码是前缀码
//    性质2; 哈夫曼编码是最优前缀码



public class Tree {
}
