package arithmetic;
// 数据结构
//  数据的逻辑结构:
//       线性结构: 线性表,栈(特殊线性表),队列(特殊线性表),字符串,数组,广义表
//       非线性结构: 树形结构/图形结构
//  数据的存储结构: 顺序存储/链式存储
//  数据的运算: 查找/排序/删除/修改等.

// 查找: 查找表
// 查找表是由同一类的数据元素(或记录)构成的集合.由于"集合"中的数据元素之间存在着松散关系,因此查找表是一种应用灵便的结构(没有严格的前驱和后继关系)
// 什么是查找? : 根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素或记录
// ~ 关键字: 用来标识一个数据元素(或记录)的某个数据项的值
//   1.主关键字 可唯一地标识一个记录的关键字是主关键字
//   2.主关键字 反之,用以罗干记录的关键字是次关键字
// 查找成功否? 若查找表中存在的这样一个记录,则称查找成功.
//           查找结果给出整个记录的消息,或指示记录在查找表中的位置
//           否则称查找不成功:查找结果给出空记录或空指针

// 顺序查找:
//  应用范围 :
//  1.顺序表或线性链表表示的静态查找表
//  2.表内元素之间无序
//  缺点:AS太长,时间效率太低

// 折半查找:每次将待查找记录所在区间缩小一半
// 应用范围:
// 1. 必须是有序的,如果无序建议先排序
// 实现方法,递归和非递归

// 插值查找
// {1,2,3,4,5,6,7,8,9,10}
// 找1需要找很多次,是否能够自适应的方案快速定位到1呢?也就是是否可以对mid改进去加快查找速度
// 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。
// 将折半查找中的求mid 索引的公式 , low表示左边索引left, high表示右边索引right.key 就是前面我们讲的findVal
// 适用范围:
//  1.对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快.
//  2.关键字分布不均匀的情况下，该方法不一定比折半查找要好

// 斐波那契查找(黄金分割查找)

// 斐波那契(黄金分割法)

//斐波那契(黄金分割法)原理:
//斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，
//    mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列）
// 对F(k-1)-1的理解：
//  1) 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 
//    （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。
//    该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，
//    即如上图所示。从而中间位置为mid=low+F(k-1)-1
//  2) 类似的，每一子段也可以用相同的方式分割（可递归）
//  3) 但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。


// 冒泡排序
// 基本思想:
//   通过对待排序序列从前向后(从下标较小的元素开始),依次比较相邻的值,
//若发现逆序则交换,使较大的元素逐渐从前移向后部.就像水底下的气泡一样逐渐向上冒
// 优化:
//   因为排序的过程中,各元素不断接近自己的位置,如果一趟比较下来没有进行过交换,
//就说明序列有序,一次要在排序过程中设置一个标志flag判断元素是否进行过交换,从而
//减少不必要的比较
public class D {
    public static void main(String[] args) {
        int mid = 10;
        int temp =mid-1;
        System.out.println(mid);
        System.out.println(temp);
    }

}
